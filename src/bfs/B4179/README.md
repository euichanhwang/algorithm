## [백준 4179 : 불!](https://www.acmicpc.net/problem/4179)  
### 💡접근 방법 : bfs응용- 시작점이 두 종류일 때  
- 시작점이 두 종류인 bfs를 구현할 때는, 각각 시작점에 대한 bfs를 모두 구현함으로서 해결이 가능하다.  
- 지훈이는 신경쓰지 말고, 불에 대한 bfs를 돌려서 미리 각 칸에 불이 전파되는 시간을 구한다.  
- 이후, 지훈이에 대한 bfs를 돌리는데 만약 지훈이가 특정 칸을 x시간에 최초로 방문할 수 있는데 그 칸에 x시간이나 그 이전에 불이 붙는다면 그 칸에 갈 수 없다.  
- 거리를 나타내는 dist1,dist2배열을 -1로 초기화한 후 불인 경우에만 0, 지훈이인 경우에만 0을 각각 대입한다.  
### 미로 입력 (J는 지훈이의 위치, F는 불의 위치, #은 벽, o는 지나갈 수 있는 공간)
\#\#\#\#  
#JF#  
#oo#  
#oo#     
### 불에 대한 bfs를 마친 후
이차원 dist1배열이  
-1-1-1-1  
-1 1 0-1  
-1 2 1-1  
-1 3 2-1  
이런 식으로 저장됨을 알 수 있다.  
### 지훈이에 대한 bfs를 구현할 때 (0이 출발 지점)
이차원 dist2배열이 초기에  
-1-1-1-1     
-1 0-1-1  
-1-1-1-1  
-1-1-1-1  
으로 저장된 후, bfs를 시작하면 불의 전파 위치를 고려하지 않고 bfs를 구현하면  
-1-1-1-1    
-1 0 1-1  
-1 1 2-1  
-1 2 3-1  
이런 식인데, 불의 전파 시간보다 늦게 가거나 불이 전파될 때와 동시에는 갈 수 없다. 따라서,  
-1-1-1-1  
-1 0 X-1  
-1 1 X-1  
-1 2 X-1  
이런 식으로 저장된다. X는 갈 수 없는 곳이며 실제로는 -1이 저장되어 있다.  
마지막 2를 넘어서서 탈출하면, 현재 위치에서 +1을 더해준다.  
```c++
 if(nx<0||nx>=r||ny<0||ny>=c) //탈출에 성공했다
            {
                cout << dist2[cur.X][cur.Y]+1;
                return 0;
            }
```  
while루프를 다 돌았음에도 탈출에 실패했다면, IMPOSSIBLE을 출력한다.  
### 예외조건  
불의 전파시간을 고려할 때, 다음과 같은 예외를 고려해야 한다.  
3 4  
###F  
oJ#o  
###o  
다음과 같은 상황일 때, 불에 대한 dist1배열은  
-1-1-10  
-1-1-11  
-1-1-12  
와 같고, 지훈이에 대한 dist2배열은  
-1-1-1-1  
-1 0-1-1  
-1-1-1-1  
이다. 단순히 불의 전파 시간만 비교조건에 넣는다면 -1<=-1+1 이 참이기 때문에 탈출할 수 없게 된다.  
불의 bfs를 다 구현하고 난 후 -1은 벽과 길 뿐인데, if(dist2[nx][ny]>=0||board[nx][ny]=='#')continue; 에서  
벽일 때를 처리해줬기 때문에 남은 것은 길이다. 따라서 길이 아닌 불일 때를 조건에 추가해야 한다.  
```c++
if(dist1[nx][ny]!=-1&&dist1[nx][ny]<=dist2[cur.X][cur.Y]+1) continue; //불의 전파조건
```









