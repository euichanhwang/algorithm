## [백준 1926 : 그림](https://www.acmicpc.net/problem/1926)  
### 💡큐를 이용한 bfs의 구현 순서
1.시작하는 칸을 큐에 넣고 방문했다는 표시를 남긴다.  
2.큐에서 원소를 꺼내어 그 칸에 상하좌우로 인접한 칸에 대해 3번을 진행한다.  
3.해당 칸을 이전에 방문했다면 아무 것도 하지 않고, 처음으로 방문했다면 방문했다는 표시를 남기고 해당 칸을 큐에 삽입한다.  
4.큐가 빌 때까지 2번을 반복한다.  
**bfs 알고리즘을 응용한 문제이며, 가로와 세로의 1로 연결된 그림에서 그림의 개수와 가장 넓은 그림의 넓이를 구하는 문제이다.**
### 💡접근 과정  
- 각 그림의 시작점을 구할 때, 이중 for문을 이용해서 각 칸이 시작점이 될 수 있는지 확인한다.  
- 시작점에서 bfs 알고리즘을 통해 방문 기록을 남기고, pop한 횟수가 그림의 넓이가 된다.  
- 시작점마다 개수를 1씩 증가시키면 그림의 개수를 구할 수 있다. 

**2차원 배열에 값을 입력받는 방법**  
```c++  
for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++)
            cin >> board[i][j];
```  
**bfs의 시작점을 찾는 과정. 이미 방문했거나, 0인 경우는 시작점에서 제외한다.**
```c++
for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < m; j++)
        {
            if(vis[i][j]||board[i][j]==0)continue; // 방문했거나 0번인 경우는 제외
            num++;
```
**큐를 이용한 bfs 구현**
```c++
while (!q.empty())
            {
                area++;
                pii cur=q.front(); q.pop();
                for(int dir=0;dir<4;dir++) //상하좌우 인접한 칸에 대해서 조사
                {
                    int nx=cur.X+dx[dir];
                    int ny=cur.Y+dy[dir];
                    if(nx<0||nx>=n||ny<0||ny>=m)continue; //범위 안
                    if(vis[nx][ny]||board[nx][ny]==0)continue; // 이미 방문했거나 0인경우
                    vis[nx][ny]=1;
                    q.push({nx,ny});
                }
            }
```
